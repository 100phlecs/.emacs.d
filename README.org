#+title: 100phlecs of elisp
#+PROPERTY: header-args:emacs-lisp :tangle ./init.el

I tried outemacs about a year and half ago then quit. Here I am
trying again. It takes time. If you don't feel like you have the
freedom to explore, you won't. Then you'll stop using. In short, it's
hard to use =emacs= when you don't feel free to 'waste' time. I think a
lot of things are solved - in =emacs= or outside of it - when you
realize you can 'waste' time.
May as well get returns if you got a lifetime ahead of you!

* Bootstrap 

To begin, we'll need to get the package manager ready.
This'll include both fetching and configuring it.
We'll also need some path variables set, for [[https://github.com/d12frosted/homebrew-emacs-plus/issues/378][gccemacs]].
While we're here, I'll also grab a package that keeps saves and other
files in the emacs.d directory, the [[https://github.com/emacscollective/no-littering][no-littering]] package.
For safely loading themes and such we'll move that to another file location.
Lexical binding adds flexibility/speed for the packages that detect
it.

#+begin_src emacs-lisp
;; -*- lexical-binding: t -*-
  (setenv "LIBRARY_PATH" "/opt/homebrew/lib/gcc/11:/opt/homebrew/lib/gcc/11/gcc/aarch64-apple-darwin20/11.1.0")
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

  (straight-use-package 'use-package)
  (setq straight-use-package-by-default t)

  (use-package no-littering)

  (setq custom-file "~/.emacs.d/custom.el")
   (if (file-exists-p custom-file)
       (message (concat  "File " (concat custom-file " already exists")))
     (with-temp-buffer (write-file custom-file)))
  (load custom-file)
#+end_src

* Appearance
Now that we're loading in =emacs=, it's nice to keep it clean, but not
/too/ clean
** Basic UI
Many people seem to discount the satisfaction of using the
=menu-bar-mode= - it's a great way to explore keybindings and
possibilities.

Relative line column numbers (counting which line you're on) helps
with chording commands. But of course they're useless for some
buffers, so we'll disable them.

#+begin_src emacs-lisp
  (menu-bar-mode t)
  (scroll-bar-mode -1)
  (tool-bar-mode -1)
  (tooltip-mode -1)
  (toggle-frame-maximized)
  (set-fringe-mode 10)

  (column-number-mode t)
  (global-display-line-numbers-mode t)
  (setq display-line-numbers-type 'relative)

  ;; Disable line numbers for some modes
  (dolist (mode '(org-mode-hook
                  term-mode-hook
                  shell-mode-hook
                  eshell-mode-hook))
  (add-hook mode (lambda () (display-line-numbers-mode 0))))
#+end_src

** Font 
I really enjoy [[https://github.com/be5invis/iosevka][Iosevka]]. The cramped nature of it may be offputting, but
after using it for a couple of weeks I can't use anything else.

Trying out ligatures too. Real easy with [[https://github.com/mickeynp/ligature.el][ligature.el]] - they gave me
the Iosevka example below.

#+begin_src emacs-lisp

  (set-face-attribute 'default nil :family "Iosevka Term" :height 170)
  (set-face-attribute 'fixed-pitch nil :family "Iosevka Fixed" :height 170)
  (set-face-attribute 'variable-pitch nil :family "Iosevka" :height 170)

  (use-package ligature
    :straight (ligature :type git :host github :repo "mickeynp/ligature.el" :files ("*.el" "*"))
    :config
    ;; Enable all Iosevka ligatures in programming modes
    (ligature-set-ligatures 'prog-mode '("<---" "<--"  "<<-" "<-" "->" "-->" "--->" "<->" "<-->" "<--->" "<---->" "<!--"
                                         "<==" "<===" "<=" "=>" "=>>" "==>" "===>" ">=" "<=>" "<==>" "<===>" "<====>" "<!---"
                                         "<~~" "<~" "~>" "~~>" "::" ":::" "==" "!=" "===" "!=="
                                         ":=" ":-" ":+" "<*" "<*>" "*>" "<|" "<|>" "|>" "+:" "-:" "=:" "<******>" "++" "+++"))
    ;; Enables ligature checks globally in all buffers. You can also do it
    ;; per mode with `ligature-mode'.
    (global-ligature-mode t))

#+end_src

** Modeline
For now I'm using the [[https://github.com/seagle0128/doom-modeline][doom modeline]] which does look nice. I wonder if
it distracts.

#+begin_src emacs-lisp
  (use-package doom-modeline
    :straight t
    :init (doom-modeline-mode 1)
    :custom (doom-modeline-height 20))

#+end_src

** Rainbow Parentheses/Curlies
Super nice to have in any prog file.

#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

** Theme - Solarized
After thumbing through a lot of themes, I found the [[https://github.com/bbatsov/solarized-emacs][solarized]]
themescape to be the one that just works.
Trying out a subset of it, =gruvbox= as inspiration.

#+begin_src emacs-lisp
(use-package solarized-theme)
(setq solarized-use-more-italic t)
(setq solarized-scale-markdown-headlines t)
(load-theme 'solarized-gruvbox-light)
#+end_src

* Discoverability / Navigation
Always when using emacs you want to find a way to use it more
effectively. So it's best to get packages that let you move fast and
find things.

** [[https://github.com/justbur/emacs-which-key][which key]]
A little popup that comes after you start a key chord. Super useful,
use it all the time. To 'diminish' the mode means to make it not
appear. Probably need to find the other modes for which that is applicable.

#+begin_src emacs-lisp
(use-package which-key
  :init (which-key-mode)
  :diminish which-key-mode
  :config (setq which-key-idle-delay 0.3))
#+end_src

** [[https://github.com/magit/magit][It's magit!]]
Getting used to it, a lot nicer than grabbing a terminal, that's for sure.

#+begin_src emacs-lisp
(use-package magit)
#+end_src

** yes-or-no -> y-or-n
Quicker confirmations
#+begin_src emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

** hydra
Repeatable commands. Only use it for text size, but maybe more ideas
will come or I'll stop using this.

#+begin_src emacs-lisp
(use-package hydra)
(defhydra hydra-text-scale (global-map "<f2>")
  "scale text"
  ("C-p" text-scale-increase "in")
  ("C-n" text-scale-decrease "out"))
#+end_src

** [[https://github.com/Wilfred/helpful][helpful]]
Getting comfortable at looking variables/functions is the way to go.
#+begin_src emacs-lisp
(use-package helpful)
  ;; Note that the built-in `describe-function' includes both functions
    ;; and macros. `helpful-function' is functions only, so we provide
    ;; `helpful-callable' as a drop-in replacement.
    (global-set-key (kbd "C-h f") #'helpful-callable)

    (global-set-key (kbd "C-h v") #'helpful-variable)
    (global-set-key (kbd "C-h k") #'helpful-key)

    ;; Lookup the current symbol at point. C-c C-d is a common keybinding
    ;; for this in lisp modes.
    (global-set-key (kbd "C-c C-d") #'helpful-at-point)

    ;; Look up *F*unctions (excludes macros).
    ;;
    ;; By default, C-h F is bound to `Info-goto-emacs-command-node'. Helpful
    ;; already links to the manual, if a function is referenced there.
    (global-set-key (kbd "C-h F") #'helpful-function)

    ;; Look up *C*ommands.
    ;;
    ;; By default, C-h C is bound to describe `describe-coding-system'. I
    ;; don't find this very useful, but it's frequently useful to only
    ;; look at interactive functions.
    (global-set-key (kbd "C-h C") #'helpful-command)

#+end_src
** complete at point/autocompletion
Autocompletion is smart for any sort of typing, isn't it? So I enable
[[https://company-mode.github.io/][company]] globally. It may not be a good idea, but we'll see. While I'm
touching ispell (spell check) I add a small keybind.

#+begin_src emacs-lisp
(use-package company
  :bind (:map company-active-map
	      ("<tab>" . company-complete-selection))
  :custom
  (company-minimum-prefix-length 1)
  (company-idle-delay 0.0))

(global-company-mode t)

(defun text-mode-hook-setup ()
  ;; make `company-backends' local is critcal
  ;; or else, you will have completion in every major mode, that's very annoying!
  (make-local-variable 'company-backends)

  ;; company-ispell is the plugin to complete words
  (add-to-list 'company-backends 'company-ispell)
  )

(add-hook 'text-mode-hook 'text-mode-hook-setup)
(global-set-key (kbd "C-:") #'ispell)
#+end_src

** yasnippet
Templating is sure convenient to have, wondering when I'll make more
use of it.
#+begin_src emacs-lisp
(use-package yasnippet)
(yas-global-mode 1)

(use-package doom-snippets
  :after yasnippet
  :straight (doom-snippets :type git :host github :repo "hlissner/doom-snippets" :files ("*.el" "*")))
#+end_src

** whole-line-or-region
Quick swapout to make more use of M-w instead of doing C-a C-k C-k
#+begin_src emacs-lisp
(use-package whole-line-or-region
  :straight (whole-line-or-region :type git :host github :repo "purcell/whole-line-or-region" :files ("*.el" "*")))
(whole-line-or-region-global-mode t)
#+end_src

** project management
Originally used projectile, going to give project.el a try. Don't have
much to say about it at this point.
#+begin_src emacs-lisp
(use-package project)
#+end_src

** search completion
Originally tried out ivy, going to try out  other packages and
see how it goes. For now I'll use vertico after some debilitating thought.
#+begin_src emacs-lisp
    (use-package vertico)
    (vertico-mode)

    ;; Example configuration for Consult
  (use-package consult
    ;; Replace bindings. Lazily loaded due by `use-package'.
    :bind (;; C-c bindings (mode-specific-map)
           ("C-c h" . consult-history)
           ("C-c m" . consult-mode-command)
           ("C-c b" . consult-bookmark)
           ("C-c k" . consult-kmacro)
           ;; C-x bindings (ctl-x-map)
           ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
           ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
           ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
           ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
           ;; Custom M-# bindings for fast register access
           ("M-#" . consult-register-load)
           ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
           ("C-M-#" . consult-register)
           ;; Other custom bindings
           ("M-y" . consult-yank-pop)                ;; orig. yank-pop
           ("<help> a" . consult-apropos)            ;; orig. apropos-command
           ;; M-g bindings (goto-map)
           ("M-g e" . consult-compile-error)
           ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
           ("M-g g" . consult-goto-line)             ;; orig. goto-line
           ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
           ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
           ("M-g m" . consult-mark)
           ("M-g k" . consult-global-mark)
           ("M-g i" . consult-imenu)
           ("M-g I" . consult-imenu-multi)
           ;; M-s bindings (search-map)
           ("M-s f" . consult-find)
           ("M-s F" . consult-locate)
           ("M-s g" . consult-grep)
           ("M-s G" . consult-git-grep)
           ("M-s r" . consult-ripgrep)
           ("M-s l" . consult-line)
           ("M-s L" . consult-line-multi)
           ("M-s m" . consult-multi-occur)
           ("M-s k" . consult-keep-lines)
           ("M-s u" . consult-focus-lines)
           ;; Isearch integration
           ("M-s e" . consult-isearch-history)
           :map isearch-mode-map
           ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
           ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
           ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
           ("M-s L" . consult-line-multi))           ;; needed by consult-line to detect isearch

    ;; Enable automatic preview at point in the *Completions* buffer.
    ;; This is relevant when you use the default completion UI,
    ;; and not necessary for Vertico, Selectrum, etc.
    ;;:hook (completion-list-mode . consult-preview-at-point-mode)

    ;; The :init configuration is always executed (Not lazy)
    :init

    ;; Optionally configure the register formatting. This improves the register
    ;; preview for `consult-register', `consult-register-load',
    ;; `consult-register-store' and the Emacs built-ins.
    (setq register-preview-delay 0
          register-preview-function #'consult-register-format)

    ;; Optionally tweak the register preview window.
    ;; This adds thin lines, sorting and hides the mode line of the window.
    (advice-add #'register-preview :override #'consult-register-window)

    ;; Optionally replace `completing-read-multiple' with an enhanced version.
    (advice-add #'completing-read-multiple :override #'consult-completing-read-multiple)

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)

    ;; Configure other variables and modes in the :config section,
    ;; after lazily loading the package.
    :config

    ;; Optionally configure preview. The default value
    ;; is 'any, such that any key triggers the preview.
    ;; (setq consult-preview-key 'any)
    ;; (setq consult-preview-key (kbd "M-."))
    ;; (setq consult-preview-key (list (kbd "<S-down>") (kbd "<S-up>")))
    ;; For some commands and buffer sources it is useful to configure the
    ;; :preview-key on a per-command basis using the `consult-customize' macro.
    (consult-customize
     consult-theme
     :preview-key '(:debounce 0.2 any)
     consult-ripgrep consult-git-grep consult-grep
     consult-bookmark consult-recent-file consult-xref
     consult--source-file consult--source-project-file consult--source-bookmark
     :preview-key (kbd "M-."))

    ;; Optionally configure the narrowing key.
    ;; Both < and C-+ work reasonably well.
    (setq consult-narrow-key "<") ;; (kbd "C-+")

    ;; Optionally make narrowing help available in the minibuffer.
    ;; You may want to use `embark-prefix-help-command' or which-key instead.
    ;; (define-key consult-narrow-map (vconcat consult-narrow-key "?") #'consult-narrow-help)

    ;; Optionally configure a function which returns the project root directory.
    ;; There are multiple reasonable alternatives to chose from.
    ;;;; 1. project.el (project-roots)
    (setq consult-project-root-function
          (lambda ()
            (when-let (project (project-current))
              (car (project-roots project)))))
    ;;;; 2. projectile.el (projectile-project-root)
    ;; (autoload 'projectile-project-root "projectile")
    ;; (setq consult-project-root-function #'projectile-project-root)
    ;;;; 3. vc.el (vc-root-dir)
    ;; (setq consult-project-root-function #'vc-root-dir)
    ;;;; 4. locate-dominating-file
    ;; (setq consult-project-root-function (lambda () (locate-dominating-file "." ".git")))
  )

  ;; Enable richer annotations using the Marginalia package
(use-package marginalia
  ;; Either bind `marginalia-cycle` globally or only in the minibuffer
  :bind (("M-A" . marginalia-cycle)
         :map minibuffer-local-map
         ("M-A" . marginalia-cycle))

  ;; The :init configuration is always executed (Not lazy!)
  :init

  ;; Must be in the :init section of use-package such that the mode gets
  ;; enabled right away. Note that this forces loading the package.
  (marginalia-mode))

#+end_src

* Org
** TODO need to clean this up.
The more I use it the more I wonder why I haven't used it before.
** UI Setup
#+begin_src emacs-lisp
(defun phl/org-mode-setup ()
  (org-indent-mode)
  (auto-fill-mode 1)
  (visual-line-mode 1))
#+end_src
** Grab org and its modules

#+begin_src emacs-lisp
(use-package org
  :hook (org-mode . phl/org-mode-setup)
  :config
  (setq org-agenda-start-with-log-mode t)
  (setq org-log-done 'time)
  (setq org-log-into-drawer t)
  (setq org-agenda-files '("~/Documents/ok/agenda/Tasks.org" "~/Documents/ok/agenda/Habits.org"))
  (setq org-ellipsis " ⤵"
	org-hide-emphasis-markers t)
  (setq org-todo-keywords
    '((sequence "BACKLOG(b)" "TODO(t)" "NEXT(n)" "|" "DONE(d!)")))
  
  (setq org-refile-targets
    '(("Archive.org" :maxlevel . 1)
      ("Tasks.org" :maxlevel . 1)))
  (require 'org-habit)
  (add-to-list 'org-modules 'org-habit)
  (setq org-habit-graph-column 60)
  ;; Save Org buffers after refiling!
  (advice-add 'org-refile :after 'org-save-all-org-buffers)
  :bind ("C-c a" . org-agenda))
#+end_src
** org bullets
#+begin_src emacs-lisp
(use-package org-bullets
  :after org
  :hook (org-mode . org-bullets-mode))
#+end_src
** org-roam
The best journalling app ever.
#+begin_src emacs-lisp
(use-package org-roam
  :straight t
  :init
  (setq org-roam-v2-ack t)
  :custom
  (org-roam-directory "~/Documents/ok")
  (org-roam-completion-everywhere t)
  (org-roam-dailies-capture-templates
      '(("d" "default" entry "* %<%I:%M %p>: %?"
         :if-new (file+head "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>\n"))))
  :bind (("C-c n l" . org-roam-buffer-toggle)
         ("C-c n f" . org-roam-node-find)
         ("C-c n i" . org-roam-node-insert)
         :map org-mode-map
         ("C-M-i" . completion-at-point)
         :map org-roam-dailies-map
         ("Y" . org-roam-dailies-capture-yesterday)
         ("T" . org-roam-dailies-capture-tomorrow))
  :bind-keymap
  ("C-c n d" . org-roam-dailies-map)
  :config
  (require 'org-roam-dailies) ;; Ensure the keymap is available
  (org-roam-db-autosync-mode)
  (org-roam-setup))
#+end_src
** Easily insert nodes quicker
#+begin_src emacs-lisp
(defun org-roam-node-insert-immediate (arg &rest args)
  (interactive "P")
  (let ((args (cons arg args))
        (org-roam-capture-templates (list (append (car org-roam-capture-templates)
                                                  '(:immediate-finish t)))))
    (apply #'org-roam-node-insert args)))
(global-set-key (kbd "C-c n I") #'org-roam-node-insert-immediate)
#+end_src
** org tangle

This is how one generates the configuration. And also edit this
configuration.
We can just autogenerate it with this snippet.
#+begin_src emacs-lisp
  (org-babel-do-load-languages
    'org-babel-load-languagesp
    '((emacs-lisp . t)
      (python . t)))

  (push '("conf-unix" . conf-unix) org-src-lang-modes)

  (require 'org-tempo)
  (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
  (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("py" . "src python"))
  

    ;; Automatically tangle our Emacs.org config file when we save it
  (defun phl/org-babel-tangle-config ()
    (when (string-equal (buffer-file-name)
                          (expand-file-name "~/.emacs.d/README.org"))
        ;; Dynamic scoping to the rescue
        (let ((org-confirm-babel-evaluate nil))
          (org-babel-tangle))))

    (add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'phl/org-babel-tangle-config)))
#+end_src 

** Language Server (eglot)
Originally I started with lsp-mode, but it felt chunky. Going to try
out eglot to see if it's more up my alley.
#+begin_src emacs-lisp
(use-package eglot)
#+end_src
** Dart/Flutter
Surprised how well this is integrated. You just need two packages
*** flutter.el
#+begin_src emacs-lisp
(use-package flutter
  :after dart-mode
  :bind (:map dart-mode-map
	      ("C-M-x" . #'flutter-run-or-hot-reload))
  :custom
  (setq flutter-sdk-path "/Users/100phlecs/packages/flutter/"))
#+end_src
*** dart-mode
#+begin_src emacs-lisp
(use-package dart-mode)
#+end_src

* Diagnostics
To find ways on improving, I track the time I spend as well as record
my focus time. This let's me evaluate where I slipped up and why. Not
trying to be a workaholic or anything of the sort, just want to slip
up less.
** [[https://activitywatch.net/][ActivityWatch]]
Recently started using it and like it so far. Keeps files local!
Previously I used RescueTime but eventually stopped for unknown
reasons.

#+begin_src emacs-lisp
(use-package activity-watch-mode)
(global-activity-watch-mode)
#+end_src
** Pomodoro Technique
Trying out this technique. Seeing if it works for me. I think it does
in terms of increasing my focus time.
Using [[https://github.com/TatriX/pomidor/][pomidor]], quite nice.
#+begin_src emacs-lisp
(use-package pomidor
  :bind (("<f12>" . pomidor))
  :config (setq pomidor-sound-tick nil
                pomidor-sound-tack nil)
  :hook (pomidor-mode . (lambda ()
                          (display-line-numbers-mode -1) ; Emacs 26.1+
                          (setq left-fringe-width 0 right-fringe-width 0)
                          (setq left-margin-width 2 right-margin-width 0)
                          ;; force fringe update
                          (set-window-buffer nil (current-buffer)))))
#+end_src

** TODO add sound for pomodoro
* Resources
I was only able to get my footing by following [[https://github.com/daviwil/emacs-from-scratch/][Emacs from Scratch]]. Do
check SystemCrafter's [[https://systemcrafters.net/emacs-from-scratch/][wiki page]] for information if videos are too much
for you!


