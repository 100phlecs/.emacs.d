#+title: 100phlecs of elisp
#+PROPERTY: header-args:emacs-lisp :tangle ./init.el


* In retrospect
:PROPERTIES:
:TOC:     :ignore (this)
:END:

Emacs starts with the buffer labeled *GNU EMACS*. Most veterans advise
to disable it immediately! But if I could go back in time, I WOULDN'T
disable it. I would read everything it offered.

It takes time to read it all of course. Who would want to spend an
evening reading through a four decade old text-editor manual? So when
I started out I used Google to look for shortcuts, which usually
worked and saved time... but not for the long term. Google doesn't
bake in concepts and keybindings. Only effort and patience does.

Anyway, yeah, that would've been nice. To use the manual from the
get-go. Because I bet if you do, once you're done reading, you'll not
have any gaps despite being a beginner. Emacs would be yours to
extend.

I would be curious how many users traversed through the entire *GNU
EMACS* buffer.

* Table of Contents
:PROPERTIES:
:TOC:      :include all :depth 4 :force (depth) :ignore (this) :local (depth)
:END:
:CONTENTS:
- [[#bootstrapping][Bootstrapping]]
  - [[#starting-up][Starting up]]
  - [[#more-path-loading][More path loading]]
  - [[#diminish][Diminish]]
- [[#appearance][Appearance]]
  - [[#basic-ui][Basic UI]]
  - [[#font][Font]]
  - [[#rainbow-parenthesescurlies][Rainbow Parentheses/Curlies]]
  - [[#theme---solarized][Theme - Solarized]]
  - [[#moody][moody]]
- [[#discoverability--navigation][Discoverability / Navigation]]
  - [[#which-key][which key]]
  - [[#its-magit][It's magit!]]
  - [[#expand-region][expand region]]
  - [[#keybindings][keybindings]]
  - [[#yes-or-no---y-or-n][yes-or-no -> y-or-n]]
  - [[#hydra][hydra]]
  - [[#helpful][helpful]]
  - [[#complete-at-pointautocompletion][complete at point/autocompletion]]
  - [[#yasnippet][yasnippet]]
  - [[#whole-line-or-region][whole-line-or-region]]
  - [[#project-management][project management]]
  - [[#buffer-management][buffer management]]
  - [[#search-completion][search completion]]
    - [[#vertico][Vertico]]
    - [[#corfu][Corfu]]
    - [[#orderless][Orderless]]
    - [[#consult][Consult]]
    - [[#marginalia][Marginalia]]
    - [[#embark--avy][Embark & Avy]]
- [[#org][Org]]
  - [[#ui-setup][UI Setup]]
  - [[#grab-org-and-its-modules][Grab org and its modules]]
  - [[#org-bullets][org bullets]]
  - [[#org-roam][org-roam]]
  - [[#org-toc][org-toc]]
  - [[#easily-insert-nodes-quicker][Easily insert nodes quicker]]
  - [[#org-tangle][org tangle]]
  - [[#org-templates--tags][org templates & tags]]
- [[#programming][Programming]]
  - [[#eshell][Eshell]]
  - [[#language-server-lsp-mode][Language Server (lsp-mode)]]
  - [[#dartflutter][Dart/Flutter]]
    - [[#flutterel][flutter.el]]
    - [[#dart-mode][dart-mode]]
- [[#diagnostics][Diagnostics]]
  - [[#esup][ESUP]]
  - [[#activitywatch][ActivityWatch]]
  - [[#pomodoro-technique][Pomodoro Technique]]
- [[#resources][Resources]]
:END:

* Bootstrapping
** Starting up
Lexical binding adds flexibility/speed for the packages that detect
it. And then package managers makes things easy.  We'll also need some path
variables set, for [[https://github.com/d12frosted/homebrew-emacs-plus/issues/378][gccemacs]] and terminal.  While we're here, I'll also
grab a package that keeps saves and other files in the emacs.d
directory, the [[https://github.com/emacscollective/no-littering][no-littering]] package. If you don't set this early on,
there'll be a lot of litter.

For safely loading themes and such we'll move that to another
file. Then as a final touch we'll see how long it takes for emacs to
start.

#+begin_src emacs-lisp
  ;; -*- lexical-binding: t -*-
  (setenv "LIBRARY_PATH" "/opt/homebrew/lib/gcc/11:/opt/homebrew/lib/gcc/11/gcc/aarch64-apple-darwin20/11.1.0")
  
  (setq gc-cons-threshold (* 50 1000 1000))
    (defvar bootstrap-version)
    (let ((bootstrap-file
           (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
          (bootstrap-version 5))
      (unless (file-exists-p bootstrap-file)
        (with-current-buffer
            (url-retrieve-synchronously
             "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
             'silent 'inhibit-cookies)
          (goto-char (point-max))
          (eval-print-last-sexp)))
      (load bootstrap-file nil 'nomessage))

    (straight-use-package 'use-package)
    (setq straight-use-package-by-default t)

    (use-package no-littering)

    (setq custom-file "~/.emacs.d/custom.el")
     (if (file-exists-p custom-file)
         (message (concat  "File " (concat custom-file " already exists")))
       (with-temp-buffer (write-file custom-file)))
    (load custom-file)

  (add-hook 'emacs-startup-hook
          (lambda ()
            (message "Emacs ready in %s with %d garbage collections."
                     (format "%.2f seconds"
                             (float-time
                              (time-subtract after-init-time before-init-time)))
                     gcs-done)))
#+end_src

** More [[https://github.com/purcell/exec-path-from-shell][path loading]]
Need to get the environment set correctly, otherwise terminals won't
work or certain packages. This is for GUI emacs.

#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :init
    (exec-path-from-shell-initialize))
#+end_src

** [[https://github.com/myrjola/diminish.el][Diminish]]
To 'diminish' a mode is to no longer have it show up in the
modeline. Useful to remove clutter from the modeline.

#+begin_src emacs-lisp
  (use-package diminish)
#+end_src

* Appearance
Now that we're loading in =emacs=, it's nice to keep it clean, but not
/too/ clean.
** Basic UI
Many people seem to discount the satisfaction of using the
=menu-bar-mode= - it's a great way to explore and remind yourself. I
find myself using my mouse more than I thought I would - to scroll a
buffer, click a command, resize stuff, etc.

Relative line column numbers (counting which line you're on) helps
with command chording. But of course they're useless for some
buffers, so we'll disable them.

#+begin_src emacs-lisp
  (menu-bar-mode t)
  (scroll-bar-mode -1)
  (tool-bar-mode -1)
  (tooltip-mode -1)
  (toggle-frame-maximized)
  (set-fringe-mode 10)

  (column-number-mode t)
  (setq display-line-numbers-type 'relative)

  (add-hook 'prog-mode-hook (lambda()
                              (display-line-numbers-mode)
                              (electric-pair-mode)))
#+end_src

** Font 
I really enjoy [[https://github.com/be5invis/iosevka][Iosevka]]. The cramped nature of it may be off-putting, but
after using it for a couple of weeks I can't use anything else.

Comes with ligatures. Real easy with [[https://github.com/mickeynp/ligature.el][ligature.el]] - they gave me
the Iosevka example below. 

#+begin_src emacs-lisp

  (set-face-attribute 'default nil :family "Iosevka Term" :height 170)
  (set-face-attribute 'fixed-pitch nil :family "Iosevka Fixed" :height 170)
  (set-face-attribute 'variable-pitch nil :family "Iosevka" :height 170)

  (use-package ligature
    :straight (ligature :type git :host github :repo "mickeynp/ligature.el" :files ("*.el" "*"))
    :config
    ;; Enable all Iosevka ligatures in programming modes
    (ligature-set-ligatures 'prog-mode '("<---" "<--"  "<<-" "<-" "->" "-->" "--->" "<->" "<-->" "<--->" "<---->" "<!--"
                                         "<==" "<===" "<=" "=>" "=>>" "==>" "===>" ">=" "<=>" "<==>" "<===>" "<====>" "<!---"
                                         "<~~" "<~" "~>" "~~>" "::" ":::" "==" "!=" "===" "!=="
                                         ":=" ":-" ":+" "<*" "<*>" "*>" "<|" "<|>" "|>" "+:" "-:" "=:" "<******>" "++" "+++"))
    ;; Enables ligature checks globally in all buffers. You can also do it
    ;; per mode with `ligature-mode'.
    (global-ligature-mode t))

#+end_src

** [[https://github.com/Fanael/rainbow-delimiters][Rainbow Parentheses/Curlies]]
Super nice to have in any prog file.

#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode)
    :diminish rainbow-delimiters-mode)
#+end_src

** Theme - Solarized
After thumbing through a lot of themes, I found the [[https://github.com/bbatsov/solarized-emacs][solarized]]
themescape to be the one that just works.
Trying out a subset of it.

#+begin_src emacs-lisp
  (use-package solarized-theme
  :config
  (load-theme 'solarized-gruvbox-light t)
  (let ((line (face-attribute 'mode-line :underline)))
    (set-face-attribute 'mode-line          nil :overline   line)
    (set-face-attribute 'mode-line-inactive nil :overline   line)
    (set-face-attribute 'mode-line-inactive nil :underline  line)
    (set-face-attribute 'mode-line          nil :box        nil)
    (set-face-attribute 'mode-line-inactive nil :box        nil)
    (set-face-attribute 'mode-line-inactive nil :background "#f9f2d9"))
  (setq solarized-use-more-italic t)
  (setq solarized-scale-markdown-headlines t))
  
#+end_src
** [[https://github.com/tarsius/moody][moody]]
Stealing some theme management :~)
#+begin_src emacs-lisp
  (use-package moody
    :config
    (setq x-underline-at-descent-line t)
    (setq moody-mode-line-height 20)
    (moody-replace-mode-line-buffer-identification)
    (moody-replace-vc-mode)
    (moody-replace-eldoc-minibuffer-message-function))
#+end_src

* Discoverability / Navigation

** [[https://github.com/justbur/emacs-which-key][which key]]
A little popup that comes after you start a key chord. Super useful,
use it all the time, excessively. 

#+begin_src emacs-lisp
(use-package which-key
  :init (which-key-mode)
  :diminish which-key-mode
  :config (setq which-key-idle-delay 0.3))
#+end_src

** [[https://github.com/magit/magit][It's magit!]]
Getting used to it, a lot nicer than grabbing a terminal, that's for sure.

#+begin_src emacs-lisp
(use-package magit)
#+end_src

** expand region
Easy way to select what you want, mostly use it for removing chars
within quotes. Maybe I don't need it. But it seems like the embark
cycle isn't a good use case for this
#+begin_src emacs-lisp
    (use-package expand-region
      :bind(
      ("C-=" . er/expand-region)))
#+end_src
** keybindings
Need a place to drop some custom keys 

#+begin_src emacs-lisp
  (defun phl-kill-this-buffer-and-close-window ()
    "Kill the active buffer and then close active window."
    (interactive)
    (kill-this-buffer)
    (delete-window))

  (global-set-key (kbd "C-x M-k") #'kill-this-buffer)
  (global-set-key (kbd "C-x k") #'phl-kill-this-buffer-and-close-window)
  (global-set-key (kbd "C-x M-K") #'kill-buffer)
  (global-set-key (kbd "C-c s") #'ispell)
#+end_src

** yes-or-no -> y-or-n
Quicker confirmations

#+begin_src emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

** [[https://github.com/abo-abo/hydra][hydra]]
Only use it for text size, but maybe more ideas
will come or I'll stop using this.

#+begin_src emacs-lisp
(use-package hydra)
(defhydra hydra-text-scale (global-map "<f2>")
  "scale text"
  ("C-p" text-scale-increase "in")
  ("C-n" text-scale-decrease "out"))
#+end_src

** [[https://github.com/Wilfred/helpful][helpful]]
Getting comfortable at looking variables/functions is the way to go.
#+begin_src emacs-lisp
(use-package helpful)
  ;; Note that the built-in `describe-function' includes both functions
    ;; and macros. `helpful-function' is functions only, so we provide
    ;; `helpful-callable' as a drop-in replacement.
    (global-set-key (kbd "C-h f") #'helpful-callable)

    (global-set-key (kbd "C-h v") #'helpful-variable)
    (global-set-key (kbd "C-h k") #'helpful-key)

    ;; Lookup the current symbol at point. C-c C-d is a common keybinding
    ;; for this in lisp modes.
    (global-set-key (kbd "C-c C-d") #'helpful-at-point)

    ;; Look up *F*unctions (excludes macros).
    ;;
    ;; By default, C-h F is bound to `Info-goto-emacs-command-node'. Helpful
    ;; already links to the manual, if a function is referenced there.
    (global-set-key (kbd "C-h F") #'helpful-function)

    ;; Look up *C*ommands.
    ;;
    ;; By default, C-h C is bound to describe `describe-coding-system'. I
    ;; don't find this very useful, but it's frequently useful to only
    ;; look at interactive functions.
    (global-set-key (kbd "C-h C") #'helpful-command)

#+end_src

** complete at point/autocompletion
Autocompletion is smart for any sort of typing, isn't it? So I enable
[[https://company-mode.github.io/][company]].

#+begin_src emacs-lisp
  (use-package company
    :after lsp-mode
    :hook (lsp-mode . company-mode)
    :bind (:map company-active-map
                ("<tab>" . company-complete-selection))
    (:map lsp-mode-map
          ("<tab>" . company-indent-or-complete-common))
    :custom
    (company-minimum-prefix-length 1)
    (company-idle-delay 0.0))
  
#+end_src

** [[https://github.com/joaotavora/yasnippet][yasnippet]]
Templating is sure convenient to have, wondering when I'll make more
use of it.
#+begin_src emacs-lisp
  (use-package yasnippet
    :init (yas-global-mode 1))
  (use-package doom-snippets
  :after yasnippet
  :straight (doom-snippets :type git :host github :repo "hlissner/doom-snippets" :files ("*.el" "*")))
#+end_src

** [[https://github.com/purcell/whole-line-or-region][whole-line-or-region]]
Quick swap-out to make more use of M-w instead of doing C-a C-k C-k
#+begin_src emacs-lisp
(use-package whole-line-or-region
  :straight (whole-line-or-region :type git :host github :repo "purcell/whole-line-or-region" :files ("*.el" "*")))
(whole-line-or-region-global-mode t)
#+end_src

** [[https://github.com/emacs-mirror/emacs/blob/master/lisp/progmodes/project.el][project]] management
Originally used projectile, going to give project.el a try. Don't have
much to say about it at this point.
#+begin_src emacs-lisp
  (use-package project
    :after magit
    :init
    (setq project-switch-commands
      '((project-find-file "Find file" nil)
       (project-find-regexp "Find regexp" nil)
       (project-find-dir "Find directory" nil)
       (project-vc-dir "VC-Dir" nil)
       (project-eshell "Eshell" nil)
       (magit-status "Magit" ?m))))

#+end_src

** [[https://github.com/karthink/popper][buffer management]]
Excellent way to manage minor buffers!
#+begin_src emacs-lisp
    (use-package popper
      :init
      (setq popper-reference-buffers
            '("\\*Messages\\*"
              "Output\\*$"
              "\\*Async Shell Command\\*"
              "\\*pomidor\\*"
              "\\*Backtrace\\*"
              pomidor-mode
              "\\*Warnings\\*"
              "^\\*eshell.*\\*$"
              eshell-mode
              flutter-mode
              helpful-mode
              help-mode
              compilation-mode))
      (popper-mode +1)
      (popper-echo-mode +1)
      (setq popper-echo-dispatch-keys
            '("C-1" "C-2" "C-3" "C-4" "C-5" "C-6" "C-7" "C-8" "C-9" "C-0"))

      (defun phl-popper-kill-buffer ()
        "Kill selected popper buffer without closing popper."
      (interactive)
      (popper-kill-latest-popup)
      (popper-toggle-latest))

      (defun phl-popper-maximize-buffer ()
        "Maximize selected popper buffer within frame."
        (interactive)
        (popper-toggle-type)
        (maximize-window))
  :bind (("M-`"   . popper-toggle-latest)
         ("C-`"   . popper-cycle)
         ("C-M-`" . popper-toggle-type)
         ("`" . phl-popper-kill-buffer)
         ("C-^" . phl-popper-maximize-buffer)
      )
  )
#+end_src

** search completion
Originally tried out ivy, going to try out all of these other packages
and see how it goes. For now I'll use vertico after some debilitating
thought.  So far consult buffer preview is pretty nice.

*** [[https://github.com/minad/vertico][Vertico]]
vertical completion in command searching

#+begin_src emacs-lisp

  (use-package vertico
    :init 
    (vertico-mode)
    (defun phl-minibuffer-backward-kill (arg)
      "When minibuffer is completing a file name delete up to parent
  folder, otherwise delete a word."
      (interactive "p")
      (if minibuffer-completing-file-name
          (if (string-match-p "/." (minibuffer-contents))
              (zap-up-to-char (- arg) ?/)
            (delete-minibuffer-contents))
        (delete-word (- arg))))

    :bind (:map vertico-map
                ("C-f" . vertico-exit)
                :map minibuffer-local-map
                ("M-DEL" . phl-minibuffer-backward-kill))
    :custom 
    (vertico-cycle t)
    (custom-set-faces '(vertico-current ((t (:background "#3a3f5a"))))))

#+end_src
  
*** [[https://github.com/minad/corfu][Corfu]]
 Typing completion 
#+begin_src emacs-lisp

    (use-package corfu
    ;; Optional customizations
    ;; :custom
    ;; (corfu-cycle t)                ;; Enable cycling for `corfu-next/previous'
    ;; (corfu-auto t)                 ;; Enable auto completion
    ;; (corfu-commit-predicate nil)   ;; Do not commit selected candidates on next input
    ;; (corfu-quit-at-boundary t)     ;; Automatically quit at word boundary
    ;; (corfu-quit-no-match t)        ;; Automatically quit if there is no match
    ;; (corfu-echo-documentation nil) ;; Do not show documentation in the echo area

    ;; Optionally use TAB for cycling, default is `corfu-complete'.
    ;; :bind (:map corfu-map
    ;;        ("TAB" . corfu-next)
    ;;        ([tab] . corfu-next)
    ;;        ("S-TAB" . corfu-previous)
    ;;        ([backtab] . corfu-previous))

    ;; You may want to enable Corfu only for certain modes.
    ;; :hook ((prog-mode . corfu-mode)
    ;;        (shell-mode . corfu-mode)
    ;;        (eshell-mode . corfu-mode))

    ;; Recommended: Enable Corfu globally.
    ;; This is recommended since dabbrev can be used globally (M-/).
    :init
    (corfu-global-mode))
#+end_src

*** [[https://github.com/oantolin/orderless][Orderless]]

Flexible searching

#+begin_src emacs-lisp

  (use-package orderless
  :init
  ;; Configure a custom style dispatcher (see the Consult wiki)
  ;; (setq orderless-style-dispatchers '(+orderless-dispatch)
  ;;       orderless-component-separator #'orderless-escapable-split-on-space)
  (setq completion-styles '(orderless)
        completion-category-defaults nil
        completion-category-overrides '((file (styles . (partial-completion))))))

#+end_src

*** [[https://github.com/minad/consult][Consult]]

improved interfacing with emacs

#+begin_src emacs-lisp

  ;; Example configuration for Consult
  (use-package consult
    ;; Replace bindings. Lazily loaded due by `use-package'.
    :bind (;; C-c bindings (mode-specific-map)
           ("C-c h" . consult-history)
           ("C-c m" . consult-mode-command)
           ("C-c b" . consult-bookmark)
           ("C-c k" . consult-kmacro)
           ;; C-x bindings (ctl-x-map)
           ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
           ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
           ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
           ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
           ;; Custom M-# bindings for fast register access
           ("M-#" . consult-register-load)
           ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
           ("C-M-#" . consult-register)
           ;; Other custom bindings
           ("M-y" . consult-yank-pop)                ;; orig. yank-pop
           ("<help> a" . consult-apropos)            ;; orig. apropos-command
           ;; M-g bindings (goto-map)
           ("M-g e" . consult-compile-error)
           ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
           ("M-g g" . consult-goto-line)             ;; orig. goto-line
           ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
           ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
           ("M-g m" . consult-mark)
           ("M-g k" . consult-global-mark)
           ("M-g i" . consult-imenu)
           ("M-g I" . consult-imenu-multi)
           ;; M-s bindings (search-map)
           ("M-s f" . consult-find)
           ("M-s F" . consult-locate)
           ("M-s g" . consult-grep)
           ("M-s G" . consult-git-grep)
           ("M-s r" . consult-ripgrep)
           ("M-s l"   . consult-line)
           ("M-s L" . consult-line-multi)
           ("M-s m" . consult-multi-occur)
           ("M-s k" . consult-keep-lines)
           ("M-s u" . consult-focus-lines)
           ;; Isearch integration
           ("M-s e" . consult-isearch-history)
           :map isearch-mode-map
           ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
           ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
           ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
           ("M-s L" . consult-line-multi))           ;; needed by consult-line to detect isearch

    ;; Enable automatic preview at point in the *Completions* buffer.
    ;; This is relevant when you use the default completion UI,
    ;; and not necessary for Vertico, Selectrum, etc.
    ;;:hook (completion-list-mode . consult-preview-at-point-mode)

    ;; The :init configuration is always executed (Not lazy)
    :init

    ;; Optionally configure the register formatting. This improves the register
    ;; preview for `consult-register', `consult-register-load',
    ;; `consult-register-store' and the Emacs built-ins.
    (setq register-preview-delay 0
          register-preview-function #'consult-register-format)

    ;; Optionally tweak the register preview window.
    ;; This adds thin lines, sorting and hides the mode line of the window.
    (advice-add #'register-preview :override #'consult-register-window)

    ;; Optionally replace `completing-read-multiple' with an enhanced version.
    (advice-add #'completing-read-multiple :override #'consult-completing-read-multiple)

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)

    ;; Configure other variables and modes in the :config section,
    ;; after lazily loading the package.
    :config

    ;; Optionally configure preview. The default value
    ;; is 'any, such that any key triggers the preview.
    ;; (setq consult-preview-key 'any)
    ;; (setq consult-preview-key (kbd "M-."))
    ;; (setq consult-preview-key (list (kbd "<S-down>") (kbd "<S-up>")))
    ;; For some commands and buffer sources it is useful to configure the
    ;; :preview-key on a per-command basis using the `consult-customize' macro.
    (consult-customize
     consult-theme
     :preview-key '(:debounce 0.2 any)
     consult-ripgrep consult-git-grep consult-grep
     consult-bookmark consult-recent-file consult-xref
     consult--source-file consult--source-project-file consult--source-bookmark
     :preview-key (kbd "M-."))

    ;; Optionally configure the narrowing key.
    ;; Both < and C-+ work reasonably well.
    (setq consult-narrow-key "<") ;; (kbd "C-+")

    ;; Optionally make narrowing help available in the minibuffer.
    ;; You may want to use `embark-prefix-help-command' or which-key instead.
    ;; (define-key consult-narrow-map (vconcat consult-narrow-key "?") #'consult-narrow-help)

    ;; Optionally configure a function which returns the project root directory.
    ;; There are multiple reasonable alternatives to chose from.
      ;;;; 1. project.el (project-roots)
    (setq consult-project-root-function
          (lambda ()
            (when-let (project (project-current))
              (car (project-roots project)))))
      ;;;; 2. projectile.el (projectile-project-root)
    ;; (autoload 'projectile-project-root "projectile")
    ;; (setq consult-project-root-function #'projectile-project-root)
      ;;;; 3. vc.el (vc-root-dir)
    ;; (setq consult-project-root-function #'vc-root-dir)
      ;;;; 4. locate-dominating-file
    ;; (setq consult-project-root-function (lambda () (locate-dominating-file "." ".git")))
    )

  (use-package consult-yasnippet
    :bind ("C-x C-y" . consult-yasnippet))
  
#+end_src

*** [[https://github.com/minad/marginalia][Marginalia]]
Command info as well as keybinding for minibuffer
#+begin_src emacs-lisp

  ;; Enable richer annotations using the Marginalia package
  (use-package marginalia
    :init
    (marginalia-mode))
#+end_src

*** [[https://github.com/oantolin/embark][Embark]] & [[https://github.com/abo-abo/avy][Avy]]
Just adding this in since it is often paired with the others.
Trying out some embark+avy combinations too.
#+begin_src emacs-lisp
  (use-package embark
    :bind (("M-o" . embark-act)
           ("M-C-o" . embark-export))
    :config
    (setq embark-cycle-key (kbd "O")))
  (use-package avy
    :demand
    :bind (("C-;" . avy-goto-char-timer)
           ("C-:" . avy-isearch)))

  (defun avy-action-embark (pt)
    (unwind-protect
        (save-excursion
          (goto-char pt)
          (embark-act))
      (select-window
       (cdr (ring-ref avy-ring 0))))
    t)
  (defun avy-action-helpful (pt)
    (save-excursion
      (goto-char pt)
      (helpful-at-point))
    (select-window
     (cdr (ring-ref avy-ring 0)))
    t)
  (defun avy-action-mark-to-char (pt)
    (activate-mark)
    (goto-char pt))

  (defun avy-action-copy-whole-line (pt)
    (save-excursion
      (goto-char pt)
      (cl-destructuring-bind (start . end)
          (bounds-of-thing-at-point 'line)
        (copy-region-as-kill start end)))
    (select-window
     (cdr
      (ring-ref avy-ring 0)))
    t)

  (defun avy-action-yank-whole-line (pt)
    (avy-action-copy-whole-line pt)
    (save-excursion (yank))
    t)

  (defun avy-action-kill-whole-line (pt)
    (save-excursion
      (goto-char pt)
      (kill-whole-line))
    (select-window
     (cdr
      (ring-ref avy-ring 0)))
    t)
  (defun avy-action-teleport-whole-line (pt)
    (avy-action-kill-whole-line pt)
    (save-excursion (yank)) t)

  (setf (alist-get ?t avy-dispatch-alist) 'avy-action-teleport
        (alist-get ?T avy-dispatch-alist) 'avy-action-teleport-whole-line)
  (setf (alist-get ?k avy-dispatch-alist) 'avy-action-kill-stay
        (alist-get ?K avy-dispatch-alist) 'avy-action-kill-whole-line)
  (setf (alist-get ?y avy-dispatch-alist) 'avy-action-yank
        (alist-get ?w avy-dispatch-alist) 'avy-action-copy
        (alist-get ?W avy-dispatch-alist) 'avy-action-copy-whole-line
        (alist-get ?Y avy-dispatch-alist) 'avy-action-yank-whole-line)
  (setf (alist-get ?  avy-dispatch-alist) 'avy-action-mark-to-char)
  (setf (alist-get ?H avy-dispatch-alist) 'avy-action-helpful)
  (setf (alist-get ?o avy-dispatch-alist) 'avy-action-embark)

#+end_src

* Org
The more I use it the more I wonder why I haven't used it before.
** UI Setup

#+begin_src emacs-lisp
(defun phl-org-mode-setup ()
  (org-indent-mode)
  (auto-fill-mode 1)
  (visual-line-mode 1))
#+end_src

** Grab org and its modules

#+begin_src emacs-lisp
(use-package org
  :hook (org-mode . phl-org-mode-setup)
  :config
  (setq org-agenda-start-with-log-mode t)
  (setq org-log-done 'time)
  (setq org-log-into-drawer t)
  (setq org-agenda-files '("~/Documents/notes/agenda/Tasks.org" "~/Documents/notes/agenda/Habits.org"))
  (setq org-ellipsis " ⤵"
	org-hide-emphasis-markers t)
  (setq org-todo-keywords
    '((sequence "BACKLOG(b)" "TODO(t)" "NEXT(n)" "|" "DONE(d!)")))
  
  (setq org-refile-targets
    '(("Archive.org" :maxlevel . 1)
      ("Tasks.org" :maxlevel . 1)))
  (require 'org-habit)
  (add-to-list 'org-modules 'org-habit)
  (setq org-habit-graph-column 60)
  ;; Save Org buffers after refiling!
  (advice-add 'org-refile :after 'org-save-all-org-buffers)
  :bind ("C-c a" . org-agenda))
#+end_src

** org bullets
#+begin_src emacs-lisp
(use-package org-bullets
  :after org
  :hook (org-mode . org-bullets-mode))
#+end_src

** org-roam
Makes writing easy compared to everything else I've tried.
#+begin_src emacs-lisp
  (use-package org-roam
    :straight t
    :demand
    :init
    (setq org-roam-v2-ack t)
    :custom
    (org-roam-directory "~/Documents/notes")
    (org-roam-completion-everywhere t)

    (defun phl-org-roam-rg ()
      "Search across the content of the root org dir."
      (interactive)
      (consult-ripgrep org-roam-directory))

    (org-roam-dailies-capture-templates
     '(("d" "default" entry "* %<%I:%M %p>: %?"
        :if-new (file+head "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>\n"))))


    (org-roam-capture-templates
     '(("d" "default" plain
        "%?"
        :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
        :unnarrowed t)
       ("p" "book notes" plain
        "\n* Source\n\nAuthor: %^{Author}\nTitle: ${title}\nYear :%^{Year}\n\n* Summary\n\n%?"
        :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
        :unnarrowed t)
       )
     )

    :bind (("C-c n l" . org-roam-buffer-toggle)
           ("C-c n f" . org-roam-node-find)
           ("C-c n i" . org-roam-node-insert)
           ("C-c n r" . phl-org-roam-rg)
           :map org-mode-map
           ("C-M-i" . completion-at-point)
           :map org-roam-dailies-map
           ("Y" . org-roam-dailies-capture-yesterday)
           ("T" . org-roam-dailies-capture-tomorrow))
    :bind-keymap
    ("C-c n d" . org-roam-dailies-map)
    :config
    (require 'org-roam-dailies) ;; Ensure the keymap is available
    (org-roam-db-autosync-mode)
    (org-roam-setup))
#+end_src

** org-toc
#+begin_src emacs-lisp
(use-package org-make-toc)
#+end_src

** Easily insert nodes quicker

#+begin_src emacs-lisp
(defun org-roam-node-insert-immediate (arg &rest args)
  (interactive "P")
  (let ((args (cons arg args))
        (org-roam-capture-templates (list (append (car org-roam-capture-templates)
                                                  '(:immediate-finish t)))))
    (apply #'org-roam-node-insert args)))
(global-set-key (kbd "C-c n I") #'org-roam-node-insert-immediate)
#+end_src

** org tangle

This is how one generates the configuration. And also edit this
configuration.
We can just autogenerate it with this snippet.
#+begin_src emacs-lisp
  (org-babel-do-load-languages
    'org-babel-load-languagesp
    '((emacs-lisp . t)
      (python . t)))
  (setq org-src-tab-acts-natively t)
  (push '("conf-unix" . conf-unix) org-src-lang-modes)

  (require 'org-tempo)

  (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
  (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("py" . "src python"))


  ;; Automatically tangle our .org config file when we save it
  (defun phl-org-babel-tangle-config ()
    (when (string-equal (buffer-file-name)
                        (expand-file-name "~/.emacs.d/README.org"))
      ;; Dynamic scoping to the rescue
      (let ((org-confirm-babel-evaluate nil))
        (org-babel-tangle))))

  (add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'phl-org-babel-tangle-config)))
#+end_src

** org templates & tags
To make it easier to write up notes around certain domains, as well as
having a project note to show up in agenda.

#+begin_src emacs-lisp


  (defun phl-org-roam-filter-by-tag (tag-name)
          (lambda (node)
            (member tag-name (org-roam-node-tags node))))

        (defun phl-org-roam-list-notes-by-tag (tag-name)
          (mapcar #'org-roam-node-file
                  (seq-filter
                   (phl-org-roam-filter-by-tag tag-name)
                   (org-roam-node-list))))

        (defun phl-org-roam-refresh-agenda-list ()
          (interactive)
          (setq org-agenda-files (phl-org-roam-list-notes-by-tag "Project")))

        ;; Build the agenda list the first time for the session
        (phl-org-roam-refresh-agenda-list)

        (defun phl-org-roam-project-finalize-hook ()
          "Adds the captured project file to `org-agenda-files' if the
        capture was not aborted."
          ;; Remove the hook since it was added temporarily
          (remove-hook 'org-capture-after-finalize-hook #'phl-org-roam-project-finalize-hook)

          ;; Add project file to the agenda list if the capture was confirmed
          (unless org-note-abort
            (with-current-buffer (org-capture-get :buffer)
              (add-to-list 'org-agenda-files (buffer-file-name)))))

        (defun phl-org-roam-find-project ()
          (interactive)
          ;; Add the project file to the agenda after capture is finished
          (add-hook 'org-capture-after-finalize-hook #'phl-org-roam-project-finalize-hook)

          ;; Select a project file to open, creating it if necessary
          (org-roam-node-find
           nil
           nil
           (phl-org-roam-filter-by-tag "Project")
           :templates
           '(("p" "project" plain "* Goals\n\n%?\n\n* Tasks\n\n** TODO Add initial tasks\n\n* Dates\n\n"
              :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+category: ${title}\n#+filetags: Project")
              :unnarrowed t))))

        (defun phl-org-roam-capture-inbox ()
          (interactive)
          (org-roam-capture- :node (org-roam-node-create)
                             :templates '(("i" "inbox" plain "* %?"
                                          :if-new (file+head "Inbox.org" "#+title: Inbox\n")))))

        (defun phl-org-roam-capture-task ()
          (interactive)
          ;; Add the project file to the agenda after capture is finished
          (add-hook 'org-capture-after-finalize-hook #'phl-org-roam-project-finalize-hook)

          ;; Capture the new task, creating the project file if necessary
          (org-roam-capture- :node (org-roam-node-read
                                    nil
                                    (phl-org-roam-filter-by-tag "Project"))
                             :templates '(("p" "project" plain "** TODO %?"
                                           :if-new (file+head+olp "%<%Y%m%d%H%M%S>-${slug}.org"
                                                                  "#+title: ${title}\n#+category: ${title}\n#+filetags: Project"
                                                                  ("Tasks"))))))

        (defun phl-org-roam-copy-todo-to-today ()
          (interactive)
          (let ((org-refile-keep t) ;; Set this to nil to delete the original!
                (org-roam-dailies-capture-templates
                  '(("t" "tasks" entry "%?"
                     :if-new (file+head+olp "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>\n" ("Tasks")))))
                (org-after-refile-insert-hook #'save-buffer)
                today-file
                pos)
            (save-window-excursion
              (org-roam-dailies--capture (current-time) t)
              (setq today-file (buffer-file-name))
              (setq pos (point)))

            ;; Only refile if the target file is different than the current file
            (unless (equal (file-truename today-file)
                           (file-truename (buffer-file-name)))
              (org-refile nil nil (list "Tasks" today-file nil pos)))))

        (add-to-list 'org-after-todo-state-change-hook
                     (lambda ()
                       (when (equal org-state "DONE")
                         (phl-org-roam-copy-todo-to-today))))

          (global-set-key (kbd "C-c n t") #'phl-org-roam-capture-task)
#+end_src

* Programming
** Eshell
It just works.
#+begin_src emacs-lisp
      (defun phl-start-new-eshell ()
        "Spawn a new eshell always."
      (interactive)
      (eshell)
      (rename-uniquely))

  (global-set-key (kbd "C-c e") #'phl-start-new-eshell)
#+end_src
** Language Server (lsp-mode)
Using lsp-mode because it was snappier after all.
#+begin_src emacs-lisp
  (use-package lsp-mode
    :commands (lsp lsp-deffered)
    :init
    (setq lsp-keymap-prefix "C-c l")

    :config
    (lsp-enable-which-key-integration t))

  (use-package lsp-ui
    :hook (lsp-mode . lsp-ui-mode)
    :custom
    (lsp-ui-doc-position 'bottom))
#+end_src
** Dart/Flutter
Surprised how well this is integrated. You just need two packages
*** flutter.el
#+begin_src emacs-lisp
(use-package flutter
  :after dart-mode
  :bind (:map dart-mode-map
	      ("C-M-x" . #'flutter-run-or-hot-reload))
  :custom
  (setq flutter-sdk-path "/Users/100phlecs/packages/flutter/"))
#+end_src

*** dart-mode
#+begin_src emacs-lisp
  (use-package dart-mode
    :hook (dart-mode . lsp))
  (use-package lsp-dart
    :init
    (setq lsp-dart-sdk-dir "/Users/100phlecs/packages/flutter/bin/cache/dart-sdk")
    (setq lsp-dart-flutter-sdk-dir "/Users/100phlecs/packages/flutter")
    (setq lsp-dart-enable-sdk-formatter t))
#+end_src

* Diagnostics
To find ways on improving, I track the time I spend as well as record
my focus time. This let's me evaluate where I slipped up and why. Not
trying to be a workaholic or anything of the sort, just want to slip
up less. This is also a catch category for emacs shenanigans
** ESUP

#+begin_src emacs-lisp
  (use-package esup
    :config
    (setq esup-depth 0))
#+end_src

** [[https://activitywatch.net/][ActivityWatch]]
Recently started using it and like it so far. Keeps files local!
Previously I used RescueTime but eventually stopped for unknown
reasons.

#+begin_src emacs-lisp
  (use-package activity-watch-mode
    :init
     (global-activity-watch-mode)
    :diminish activity-watch-mode)

#+end_src

** Pomodoro Technique
Trying out this technique. Seeing if it works for me. I think it does
in terms of increasing my focus time.
Using [[https://github.com/TatriX/pomidor/][pomidor]], quite nice.
#+begin_src emacs-lisp
  (use-package pomidor
    :bind (("<f12>" . pomidor))
    :config (setq pomidor-sound-tick nil
                  pomidor-sound-tack nil)
    :hook (pomidor-mode . (lambda ()
                            (display-line-numbers-mode -1) ; Emacs 26.1+
                            (setq left-fringe-width 0 right-fringe-width 0)
                            (setq left-margin-width 2 right-margin-width 0)
                            ;; force fringe update
                            (set-window-buffer nil (current-buffer)))))
  (setq gc-cons-threshold (* 2 1000 1000))
#+end_src

* Resources
I was only able to follow a path of least resistance by following
[[https://github.com/daviwil/emacs-from-scratch/][Emacs from Scratch]]. Do check SystemCrafter's [[https://systemcrafters.net/emacs-from-scratch/][wiki page]] for information
if videos are too much for you!


