#+title 100phlecs of elisp
#+PROPERTY: header-args:emacs-lisp :tangle ./init.el

* Bootstrap 

To begin, we'll need to get the package manager ready.
This'll include both fetching and configuring it.
We'll also need some path variables set, for [[https://github.com/d12frosted/homebrew-emacs-plus/issues/378][gccemacs]].
While we're here, I'll also grab a package that keeps saves and other
files in the emacs.d directory, the [[https://github.com/emacscollective/no-littering][no-littering]] package.
For safely loading themes and such we'll move that to another file.


#+begin_src emacs-lisp
  (setenv "LIBRARY_PATH" "/opt/homebrew/lib/gcc/11:/opt/homebrew/lib/gcc/11/gcc/aarch64-apple-darwin20/11.1.0")
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

  (straight-use-package 'use-package)
  (setq straight-use-package-by-default t)

  (use-package no-littering)

  (setq custom-file "~/.emacs.d/custom.el")
   (if (file-exists-p custom-file)
       (message (concat  "File " (concat custom-file " already exists")))
     (with-temp-buffer (write-file custom-file)))
  (load custom-file)
#+end_src

* Appearance
Now that we're loading in =emacs=, it's nice to keep it clean, but not
/too/ clean
** Basic UI
Many people seem to discount the satisfaction of using the
=menu-bar-mode= - it's a great way to explore keybindings and
possibilities.

Relative line column numbers (counting which line you're on) helps
with chording commands. But of course they're useless for some
buffers, so we'll disable them.

#+begin_src emacs-lisp
  (menu-bar-mode t)
  (scroll-bar-mode -1)
  (tool-bar-mode -1)
  (tooltip-mode -1)
  (toggle-frame-maximized)
  (set-fringe-mode 10)

  (column-number-mode t)
  (global-display-line-numbers-mode t)
  (setq display-line-numbers-type 'relative)

  ;; Disable line numbers for some modes
  (dolist (mode '(org-mode-hook
                  term-mode-hook
                  shell-mode-hook
                  eshell-mode-hook))
  (add-hook mode (lambda () (display-line-numbers-mode 0))))
#+end_src

** Font 
I really enjoy [[https://github.com/be5invis/iosevka][Iosevka]]. The cramped nature of it may be offputting, but
after using it for a couple of weeks I can't use anything else.

Trying out ligatures too. Real easy with [[https://github.com/mickeynp/ligature.el][ligature.el]] - they gave me
the Iosevka example below.

#+begin_src emacs-lisp

  (set-face-attribute 'default nil :family "Iosevka Term" :height 170)
  (set-face-attribute 'fixed-pitch nil :family "Iosevka Fixed" :height 170)
  (set-face-attribute 'variable-pitch nil :family "Iosevka" :height 170)

  (use-package ligature
    :straight (ligature :type git :host github :repo "mickeynp/ligature.el" :files ("*.el" "*"))
    :config
    ;; Enable all Iosevka ligatures in programming modes
    (ligature-set-ligatures 'prog-mode '("<---" "<--"  "<<-" "<-" "->" "-->" "--->" "<->" "<-->" "<--->" "<---->" "<!--"
                                         "<==" "<===" "<=" "=>" "=>>" "==>" "===>" ">=" "<=>" "<==>" "<===>" "<====>" "<!---"
                                         "<~~" "<~" "~>" "~~>" "::" ":::" "==" "!=" "===" "!=="
                                         ":=" ":-" ":+" "<*" "<*>" "*>" "<|" "<|>" "|>" "+:" "-:" "=:" "<******>" "++" "+++"))
    ;; Enables ligature checks globally in all buffers. You can also do it
    ;; per mode with `ligature-mode'.
    (global-ligature-mode t))

#+end_src

** Modeline
For now I'm using the [[https://github.com/seagle0128/doom-modeline][doom modeline]] which does look nice. I wonder if
it distracts.

#+begin_src emacs-lisp
  (use-package doom-modeline
    :straight t
    :init (doom-modeline-mode 1)
    :custom (doom-modeline-height 20))

#+end_src

** Rainbow Parentheses/Curlies
Super nice to have in any prog file.

#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

** Theme - Solarized
After thumbing through a lot of themes, I found the [[https://github.com/bbatsov/solarized-emacs][solarized]]
themescape to be the one that just works.
Trying out a subset of it, =gruvbox= as inspiration.

#+begin_src emacs-lisp
(use-package solarized-theme)
(setq solarized-use-more-italic t)
(setq solarized-scale-markdown-headlines t)
(load-theme 'solarized-gruvbox-light)
#+end_src

* Discoverability / Navigation
Always when using emacs you want to find a way to use it more
effectively. So it's best to get packages that let you move fast and
find things.

** [[https://github.com/justbur/emacs-which-key][which key]]
A little popup that comes after you start a key chord. Super useful,
use it all the time. To 'diminish' the mode means to make it not
appear. Probably need to find the other modes for which that is applicable.

#+begin_src emacs-lisp
(use-package which-key
  :init (which-key-mode)
  :diminish which-key-mode
  :config (setq which-key-idle-delay 0.3))
#+end_src

** [[https://github.com/magit/magit][It's magit!]]
Getting used to it, a lot nicer than grabbing a terminal, that's for sure.

#+begin_src emacs-lisp
(use-package magit)
#+end_src

** yes-or-no -> y-or-n
Quicker confirmations
#+begin_src emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

** hydra
Repeatable commands. Only use it for text size, but maybe more ideas
will come or I'll stop using this.

#+begin_src emacs-lisp
(use-package hydra)
(defhydra hydra-text-scale (global-map "<f2>")
  "scale text"
  ("C-p" text-scale-increase "in")
  ("C-n" text-scale-decrease "out"))
#+end_src

** complete at point/autocompletion
Autocompletion is smart for any sort of typing, isn't it? So I enable
[[https://company-mode.github.io/][company]] globally. It may not be a good idea, but we'll see. While I'm
touching ispell (spell check) I add a small keybind.

#+begin_src emacs-lisp
(use-package company
  :bind (:map company-active-map
	      ("<tab>" . company-complete-selection))
  :custom
  (company-minimum-prefix-length 1)
  (company-idle-delay 0.0))

(global-company-mode t)

(defun text-mode-hook-setup ()
  ;; make `company-backends' local is critcal
  ;; or else, you will have completion in every major mode, that's very annoying!
  (make-local-variable 'company-backends)

  ;; company-ispell is the plugin to complete words
  (add-to-list 'company-backends 'company-ispell)
  )

(add-hook 'text-mode-hook 'text-mode-hook-setup)
(global-set-key (kbd "C-:") #'ispell)
#+end_src

** yasnippet
Templating is sure convenient to have, wondering when I'll make more
use of it.
#+begin_src emacs-lisp
(use-package yasnippet)
(yas-global-mode 1)

(use-package doom-snippets
  :after yasnippet
  :straight (doom-snippets :type git :host github :repo "hlissner/doom-snippets" :files ("*.el" "*")))
#+end_src

** whole-line-or-region
Quick swapout to make more use of M-w instead of doing C-a C-k C-k
#+begin_src emacs-lisp
(use-package whole-line-or-region
  :straight (whole-line-or-region :type git :host github :repo "purcell/whole-line-or-region" :files ("*.el" "*")))
(whole-line-or-region-global-mode t)
#+end_src

** project management
Originally used projectile, going to give project.el a try. Don't have
much to say about it at this point.
#+begin_src emacs-lisp
(use-package project)
#+end_src

* Org
** TODO need to clean this up.
The more I use it the more I wonder why I haven't used it before.
** UI Setup
#+begin_src emacs-lisp
(defun phl/org-mode-setup ()
  (org-indent-mode)
  (auto-fill-mode 1)
  (visual-line-mode 1))
#+end_src
** Grab org and its modules

#+begin_src emacs-lisp
(use-package org
  :hook (org-mode . phl/org-mode-setup)
  :config
  (setq org-agenda-start-with-log-mode t)
  (setq org-log-done 'time)
  (setq org-log-into-drawer t)
  (setq org-agenda-files '("~/Documents/ok/agenda/Tasks.org" "~/Documents/ok/agenda/Habits.org"))
  (setq org-ellipsis " â¤µ"
	org-hide-emphasis-markers t)
  (setq org-todo-keywords
    '((sequence "BACKLOG(b)" "TODO(t)" "NEXT(n)" "|" "DONE(d!)")))
  
  (setq org-refile-targets
    '(("Archive.org" :maxlevel . 1)
      ("Tasks.org" :maxlevel . 1)))
  (require 'org-habit)
  (add-to-list 'org-modules 'org-habit)
  (setq org-habit-graph-column 60)
  ;; Save Org buffers after refiling!
  (advice-add 'org-refile :after 'org-save-all-org-buffers)
  :bind ("C-c a" . org-agenda))
#+end_src
** org bullets
#+begin_src emacs-lisp
(use-package org-bullets
  :after org
  :hook (org-mode . org-bullets-mode))
#+end_src
** org-roam
The best journalling app ever.
#+begin_src emacs-lisp
(use-package org-roam
  :straight t
  :init
  (setq org-roam-v2-ack t)
  :custom
  (org-roam-directory "~/Documents/ok")
  (org-roam-completion-everywhere t)
  (org-roam-dailies-capture-templates
      '(("d" "default" entry "* %<%I:%M %p>: %?"
         :if-new (file+head "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>\n"))))
  :bind (("C-c n l" . org-roam-buffer-toggle)
         ("C-c n f" . org-roam-node-find)
         ("C-c n i" . org-roam-node-insert)
         :map org-mode-map
         ("C-M-i" . completion-at-point)
         :map org-roam-dailies-map
         ("Y" . org-roam-dailies-capture-yesterday)
         ("T" . org-roam-dailies-capture-tomorrow))
  :bind-keymap
  ("C-c n d" . org-roam-dailies-map)
  :config
  (require 'org-roam-dailies) ;; Ensure the keymap is available
  (org-roam-db-autosync-mode)
  (org-roam-setup))
#+end_src
** Easily insert nodes quicker
#+begin_src emacs-lisp
(defun org-roam-node-insert-immediate (arg &rest args)
  (interactive "P")
  (let ((args (cons arg args))
        (org-roam-capture-templates (list (append (car org-roam-capture-templates)
                                                  '(:immediate-finish t)))))
    (apply #'org-roam-node-insert args)))
(global-set-key (kbd "C-c n I") #'org-roam-node-insert-immediate)
#+end_src
** org tangle
This is how one generates the configuration.
We can just autogenerate it with this snippet.
#+begin_src emacs-lisp
;; Automatically tangle our Emacs.org config file when we save it
(defun phl/org-babel-tangle-config ()
  (when (string-equal (buffer-file-name)
                      (expand-file-name "~/.emacs.d/init.org"))
    ;; Dynamic scoping to the rescue
    (let ((org-confirm-babel-evaluate nil))
      (org-babel-tangle))))

(add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'phl/org-babel-tangle-config)))
#+end_src 

* Programming
** Language Server (eglot)
Originally I started with lsp-mode, but it felt chunky. Going to try
out eglot to see if it's more up my alley.
#+begin_src emacs-lisp
(use-package eglot)
#+end_src
** Dart/Flutter
Surprised how well this is integrated. You just need two packages
*** flutter.el
#+begin_src emacs-lisp
(use-package flutter
  :after dart-mode
  :bind (:map dart-mode-map
	      ("C-M-x" . #'flutter-run-or-hot-reload))
  :custom
  (setq flutter-sdk-path "/Users/100phlecs/packages/flutter/"))
#+end_src
*** dart-mode
#+begin_src emacs-lisp
(use-package dart-mode)
#+end_src

* Diagnostics
To find ways on improving, I track the time I spend as well as record
my focus time. This let's me evaluate where I slipped up and why. Not
trying to be a workaholic or anything of the sort, just want to slip
up less.
** [[https://activitywatch.net/][ActivityWatch]]
Recently started using it and like it so far. Keeps files local!
Previously I used RescueTime but eventually stopped for unknown
reasons.

#+begin_src emacs-lisp
(use-package activity-watch-mode)
(global-activity-watch-mode)
#+end_src
** Pomodoro Technique
Trying out this technique. Seeing if it works for me. I think it does
in terms of increasing my focus time.
Using [[https://github.com/TatriX/pomidor/][pomidor]], quite nice.
#+begin_src emacs-lisp
(use-package pomidor
  :bind (("<f12>" . pomidor))
  :config (setq pomidor-sound-tick nil
                pomidor-sound-tack nil)
  :hook (pomidor-mode . (lambda ()
                          (display-line-numbers-mode -1) ; Emacs 26.1+
                          (setq left-fringe-width 0 right-fringe-width 0)
                          (setq left-margin-width 2 right-margin-width 0)
                          ;; force fringe update
                          (set-window-buffer nil (current-buffer)))))
#+end_src

** TODO add sound for pomodoro
* Resources
I was only able to get my footing by following [[https://github.com/daviwil/emacs-from-scratch/][Emacs from Scratch]]. Do
check SystemCrafter's [[https://systemcrafters.net/emacs-from-scratch/][wiki page]] for information if videos are too much
for you!


